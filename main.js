/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => KagiFastGPTPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  apiKey: ""
};
var KagiFastGPTPlugin = class extends import_obsidian.Plugin {
  async onload() {
    await this.loadSettings();
    this.addRibbonIcon("message-circle", "Chat with Notes", (evt) => {
      new ChatModal(this.app, this).open();
    });
    this.addCommand({
      id: "open-chat-modal",
      name: "Open Chat with Notes",
      callback: () => {
        new ChatModal(this.app, this).open();
      }
    });
    this.addSettingTab(new KagiFastGPTSettingTab(this.app, this));
  }
  onunload() {
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  async searchNotes(query) {
    const searchResults = this.app.vault.getMarkdownFiles().filter((file) => {
      const content = this.app.vault.cachedRead(file);
      return content.then(
        (text) => text.toLowerCase().includes(query.toLowerCase()) || file.basename.toLowerCase().includes(query.toLowerCase())
      );
    });
    return searchResults.slice(0, 10);
  }
  async getNoteContent(file) {
    return await this.app.vault.cachedRead(file);
  }
  async callKagiFastGPT(query, context) {
    if (!this.settings.apiKey) {
      throw new Error("Kagi API key not configured. Please set it in plugin settings.");
    }
    const fullQuery = context ? `Based on the following notes from my vault:

${context}

Question: ${query}` : query;
    try {
      const response = await (0, import_obsidian.requestUrl)({
        url: "https://kagi.com/api/v0/fastgpt",
        method: "POST",
        headers: {
          "Authorization": `Bot ${this.settings.apiKey}`,
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          query: fullQuery
        })
      });
      return response.json;
    } catch (error) {
      console.error("Kagi API request failed:", error);
      throw new Error(`Failed to connect to Kagi API: ${error.message || "Network error"}`);
    }
  }
};
var ChatModal = class extends import_obsidian.Modal {
  constructor(app, plugin) {
    super(app);
    this.plugin = plugin;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: "Chat with Your Notes" });
    const searchSection = contentEl.createDiv("search-section");
    searchSection.createEl("h3", { text: "Search Notes" });
    this.searchInput = searchSection.createEl("input", {
      type: "text",
      placeholder: "Search your notes (e.g., #person, painting, artificial intelligence)"
    });
    this.searchInput.style.width = "100%";
    this.searchInput.style.marginBottom = "10px";
    const searchButton = searchSection.createEl("button", { text: "Search Notes" });
    searchButton.onclick = () => this.performSearch();
    this.resultsDiv = contentEl.createDiv("search-results");
    this.resultsDiv.style.maxHeight = "200px";
    this.resultsDiv.style.overflowY = "auto";
    this.resultsDiv.style.border = "1px solid var(--background-modifier-border)";
    this.resultsDiv.style.padding = "10px";
    this.resultsDiv.style.marginBottom = "20px";
    const chatSection = contentEl.createDiv("chat-section");
    chatSection.createEl("h3", { text: "Ask Question" });
    this.queryInput = chatSection.createEl("textarea", {
      placeholder: "Ask a question about your notes..."
    });
    this.queryInput.style.width = "100%";
    this.queryInput.style.height = "80px";
    this.queryInput.style.marginBottom = "10px";
    const chatButton = chatSection.createEl("button", { text: "Ask FastGPT" });
    chatButton.onclick = () => this.performChat();
    this.chatDiv = contentEl.createDiv("chat-results");
    this.chatDiv.style.marginTop = "20px";
    this.chatDiv.style.padding = "10px";
    this.chatDiv.style.border = "1px solid var(--background-modifier-border)";
    this.chatDiv.style.borderRadius = "5px";
  }
  async performSearch() {
    const query = this.searchInput.value.trim();
    if (!query) {
      new import_obsidian.Notice("Please enter a search query");
      return;
    }
    this.resultsDiv.empty();
    this.resultsDiv.createEl("p", { text: "Searching..." });
    try {
      const searchResults = this.app.vault.getMarkdownFiles().filter((file) => {
        var _a, _b;
        const cache = this.app.metadataCache.getFileCache(file);
        const content = ((_a = cache == null ? void 0 : cache.sections) == null ? void 0 : _a.map((s) => s.type).join(" ")) || "";
        const tags = ((_b = cache == null ? void 0 : cache.tags) == null ? void 0 : _b.map((t) => t.tag).join(" ")) || "";
        const fileName = file.basename;
        const searchText = `${fileName} ${content} ${tags}`.toLowerCase();
        return searchText.includes(query.toLowerCase());
      });
      this.resultsDiv.empty();
      if (searchResults.length === 0) {
        this.resultsDiv.createEl("p", { text: "No notes found matching your search." });
        return;
      }
      this.resultsDiv.createEl("p", { text: `Found ${searchResults.length} notes:` });
      const resultsList = this.resultsDiv.createEl("ul");
      searchResults.slice(0, 10).forEach((file) => {
        const listItem = resultsList.createEl("li");
        listItem.createEl("strong", { text: file.basename });
        listItem.createSpan({ text: ` (${file.path})` });
      });
    } catch (error) {
      this.resultsDiv.empty();
      this.resultsDiv.createEl("p", {
        text: `Search error: ${error.message}`,
        cls: "error"
      });
    }
  }
  async performChat() {
    const query = this.queryInput.value.trim();
    if (!query) {
      new import_obsidian.Notice("Please enter a question");
      return;
    }
    this.chatDiv.empty();
    this.chatDiv.createEl("p", { text: "Thinking..." });
    try {
      const searchQuery = this.searchInput.value.trim();
      let context = "";
      if (searchQuery) {
        const searchResults = this.app.vault.getMarkdownFiles().filter((file) => {
          var _a, _b;
          const cache = this.app.metadataCache.getFileCache(file);
          const content = ((_a = cache == null ? void 0 : cache.sections) == null ? void 0 : _a.map((s) => s.type).join(" ")) || "";
          const tags = ((_b = cache == null ? void 0 : cache.tags) == null ? void 0 : _b.map((t) => t.tag).join(" ")) || "";
          const fileName = file.basename;
          const searchText = `${fileName} ${content} ${tags}`.toLowerCase();
          return searchText.includes(searchQuery.toLowerCase());
        });
        const contextFiles = searchResults.slice(0, 5);
        const contextPromises = contextFiles.map(async (file) => {
          const content = await this.plugin.getNoteContent(file);
          return `## ${file.basename}
${content}

`;
        });
        const contextArray = await Promise.all(contextPromises);
        context = contextArray.join("");
      }
      const response = await this.plugin.callKagiFastGPT(query, context);
      this.chatDiv.empty();
      const answerDiv = this.chatDiv.createDiv();
      answerDiv.createEl("h4", { text: "Answer:" });
      answerDiv.createEl("p", { text: response.data.output });
      if (response.data.references && response.data.references.length > 0) {
        const refsDiv = this.chatDiv.createDiv();
        refsDiv.createEl("h4", { text: "References:" });
        const refsList = refsDiv.createEl("ul");
        response.data.references.forEach((ref) => {
          const listItem = refsList.createEl("li");
          const link = listItem.createEl("a", {
            text: ref.title,
            href: ref.url
          });
          link.setAttribute("target", "_blank");
          listItem.createEl("p", { text: ref.snippet });
        });
      }
      const metaDiv = this.chatDiv.createDiv();
      metaDiv.style.fontSize = "0.8em";
      metaDiv.style.color = "var(--text-muted)";
      metaDiv.style.marginTop = "10px";
      metaDiv.createSpan({ text: `Tokens used: ${response.data.tokens} | Response time: ${response.meta.ms}ms` });
    } catch (error) {
      this.chatDiv.empty();
      this.chatDiv.createEl("p", {
        text: `Error: ${error.message}`,
        cls: "error"
      });
    }
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var KagiFastGPTSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Kagi FastGPT Settings" });
    new import_obsidian.Setting(containerEl).setName("Kagi API Key").setDesc("Enter your Kagi API key. Get one at https://kagi.com/settings/api").addText((text) => text.setPlaceholder("Enter your API key").setValue(this.plugin.settings.apiKey).onChange(async (value) => {
      this.plugin.settings.apiKey = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("p", {
      text: "Note: FastGPT costs 1.5\xA2 per query. Make sure you have API credits at https://kagi.com/settings/billing_api"
    });
  }
};
